\documentclass{standalone}
\usepackage{asymptote}

\begin{document}
\begin{asy}[width=10cm,height=10cm]

// See http://asymptote.sourceforge.net/doc/Import.html
//import bsp;
import three;
import settings;
import plain;

// Include has the effect of doing a drop-in replacement of the file
// For some reason I can't get import to work unless it is in the same directory.
include "../MechanicsLibrary.asy"; 
include "../SceneGraph.asy"; 

// Helpful numbers.
real slopeLength = 5;
real slopeWidth = 4;
real skiLength = 3;

currentprojection=perspective( (15, 8, -15), up=Y );
// showtarget=true, autoadjust=true, center=true );

// Construct the scene...
Node scene = Node( "root", null );

// Crate a node that draws my specific plane.
Node createMyPlane(string name, real width, real height, pen pe,
        transform3 myShift=shift(0,0,0))
{
    Node n= Node(name, null);
    path3 pa =  (0,0,0)--(height,0,0)--(height,0,width)--(0,0,width)--cycle;
    n.addDrawable(PathRenderable( myShift*pa, pe));
//    n.addDrawable(SurfRenderable( surface(myShift*pa), transparent));
    return n;
}

// N frame
Node frameN = Node( "N", scene );
//frameN.addChild(createPathBasis("basisN"));
frameN.addChild(createUniformPathBasis("visbasisN", shift(0.5,0.5,0), lightgreen));
//frameN.addChild(createMyPlane("ground", slopeWidth, slopeLength, black));
Node baseLine = Node("baseline");
baseLine.addDrawable(PathRenderable((0,0,0)--(slopeLength,0,0), black));
frameN.addChild(baseLine);

// A frame
real slopeIncline = 20; // degrees.
Node frameA = Node( "A", frameN );
frameA.rotation = rotate(-slopeIncline, Z);
frameA.translation = shift(slopeLength,0,0);
//frameA.addChild(createPathBasis("basisA"));
frameA.addChild(createUniformPathBasis("visbasisA", shift(-1,0,0.5), lightblue));

frameA.addChild(createMyPlane("SkiSlope", slopeWidth, slopeLength, black,
    myShift=shift(-slopeLength, 0, 0)));

Node dimSlopeIncline = Node("dimSlopeIncline");
PathRenderable prDimSlopeIncline = PathRenderable( arc((0,0,0), 1.5, 90, 180,
        90, 180+slopeIncline, normal=(0,0,1)), black, "$\gamma$");
dimSlopeIncline.addDrawable(prDimSlopeIncline);
frameA.addChild(dimSlopeIncline);
//label("$A$", prDimSlopeIncline.mPath);

// Intermediate frame between A and B.
Node frameABinter = Node("ABinter", frameA);
frameABinter.translation = shift(-.45*slopeLength, 0, 0.55 * slopeWidth);
real dashedLineLength = 2.2;
frameABinter.addDrawable(PathRenderable((0,0,0)--(-dashedLineLength,0,0), dashed));

// B frame
real fallangle = 45; // degrees.
Node frameB = Node("B", frameABinter);
//frameB.addChild(createPathBasis("basisB"));
frameB.addChild(createUniformPathBasis("visbasisB", shift(0.5,0,0), lightred));
Node toBbasis = Node("toBbasis");
toBbasis.addDrawable(PathRenderable((0,0,0)--(0.5,0,0), dashed));
frameB.addChild(toBbasis);
frameB.rotation = rotate(-fallangle, Y);

Node dimFallAngle = Node("dimFallAngle");
dimFallAngle.addDrawable(PathRenderable(
        arc((0,0,0), 0.5, 90, 180,  90-fallangle, 180, normal=(0,-1,0)),
        black, "$\alpha$"));
frameB.addChild(dimFallAngle);

// For drawing right angle symbol.
real del = 0.1;
// Crate a node that draws my specific plane.
Node createSki(string name, real skiLength)
{
    Node n= Node(name, null);
    real hwidth = 0.25;
    real height = skiLength - hwidth;
    real radius = hwidth;
    path3 p = (0,0,0)--(0,0,2*hwidth)--
        (0, height, 2*hwidth)..(0, height+radius,hwidth)..(0,height,0)--cycle;
    n.addDrawable(PathRenderable(
            shift(0, 0, -hwidth)*p, black));
    material m = material(diffusepen=gray(0.4),
        emissivepen=gray(0.6), opacity=0.5);
    n.addDrawable(SurfRenderable(
            surface(shift(0, 0, -hwidth)*p), m));
    //n.addDrawable(PathRenderable(
    //    (0, 0,-hwidth-del)--(0,del,-hwidth-del)--(0,del,-hwidth), black));
    return n;
}
frameB.addChild(createSki("planted", skiLength));

Node createTheFallen(string name, real height)
{
    Node n = Node(name);
    triple foot = (0, height, 0);
    real limbLength = 1.0 / 1.4 * height;
    real ankleAngle = 20.0 * 3.14 / 180.0;
    // Comes from a formula like:
    // h = dsin(theta) + 2dsin(theta)/3 + dsin(q)
    // h = skiLength
    // d = limbLength
    // theta = ankleAngle
    // q = kneeAngle
    //real kneeAngle = asin(skiLength/limbLength - 5.0/3.0*sin(ankleAngle));
    real kneeAngle = 56.0 * 3.14 / 180.0;
    triple knee = foot - limbLength*(cos(ankleAngle), sin(ankleAngle), 0);
    triple hip = knee - limbLength*(cos(kneeAngle), sin(kneeAngle), 0);
    triple torso = hip - 2/3*limbLength*(cos(ankleAngle), sin(ankleAngle), 0);
    path3 p = foot -- knee -- hip -- torso;
    n.addDrawable(PathRenderable(p, black+thick));
    n.addDrawable(DotRenderable(p, red));
    n.addDrawable(PathRenderable((0,0,0)--(-dashedLineLength,0,0), dashed));
    n.addDrawable(PathRenderable(knee--(knee.x, 0,0), dashed));
    n.addDrawable(PathRenderable(hip--(hip.x, 0,0), dashed));
    n.addDrawable(PathRenderable(
        (knee.x-del, 0,0)--(knee.x-del,del,0)--(knee.x,del,0), black));
    n.addDrawable(PathRenderable(
        (hip.x-del, 0,0)--(hip.x-del,del,0)--(hip.x,del,0), black));
    n.addDrawable(PathRenderable(
        (0-del, 0,0)--(0-del,del,0)--(0,del,0), black));
    return n;
}

frameB.addChild(createTheFallen("bob", 0.5 * skiLength));

//path3 y=(0,0,0)--(0,0,1)--(1,0,1)--(1,0,0)--cycle;
//draw(y, mRed);
//filldraw(y, yellow, black);
//draw(surface(plane((0,0,0), (1, 0, 1))));

/*
real u=2.5;
real v=1;
path3 y=plane((2u,0,0),(0,2v,0),(-u,-v,0));
path3 l=rotate(90,Z)*rotate(90,Y)*y;
path3 g=rotate(90,X)*rotate(90,Y)*y;
face[] faces;
filldraw(faces.push(y),project(y),yellow);
filldraw(faces.push(l),project(l),lightgrey);
filldraw(faces.push(g),project(g),green);
add(faces);
*/

// Draw the scene
scene.render(scale3(1));

//label("$A$", frameA.getTransform() *  (0, 1, 0));

// Draw the N basis.
//drawBasis(scale3(1), 1, "N");

/*
// ***************************************************************************
// I think we might be able to do MG-style frame definitions...
// Random experiment, just to see if it works:
real theta = -30; // argh, rotate takes a number of degrees, not radians
triple ax = rotate(theta, Y)*X;
triple ay = rotate(theta, Y)*Y;
triple az = rotate(theta, Y)*Z;
real len = 3;
triple N2 = (10, 0, 0);
draw(shift(N2)*(zero--(len*ax)),red+medium,Arrow3); 
draw(shift(N2)*(zero--(len*ay)),green+medium,Arrow3);
draw(shift(N2)*(zero--(len*az)),blue+medium,Arrow3);
draw(shift(N2)*(zero--len*(2*ax+az)), red, Arrow3);
// Cool it works! 
// TODO package this into useful library stuff and remove form this example.
// ***************************************************************************
*/

/*
// Define our position vectors... in the N frame.
triple zero = (0,0,0);
triple No = (0, 0, 0);
triple A = (0, 8, 20);
triple B = (0, 8, 0);
triple C = (15, 8, 0);
triple Qz = (0,0,8);
triple Qxz = (7,0,8);
triple Q = (7, 5, 8);

// ***************************************************************************
// I think we might be able to do MG-style frame definitions...
// Random experiment, just to see if it works:
real theta = -30; // argh, rotate takes a number of degrees, not radians
triple ax = rotate(theta, Y)*X;
triple ay = rotate(theta, Y)*Y;
triple az = rotate(theta, Y)*Z;
real len = 3;
triple N2 = (10, 0, 0);
draw(shift(N2)*(zero--(len*ax)),red+medium,Arrow3); 
draw(shift(N2)*(zero--(len*ay)),green+medium,Arrow3);
draw(shift(N2)*(zero--(len*az)),blue+medium,Arrow3);
draw(shift(N2)*(zero--len*(2*ax+az)), red, Arrow3);
// Cool it works! 
// TODO package this into useful library stuff and remove form this example.
// ***************************************************************************

// We can predefine surfaces as geometry plus affine transforms.
surface point = scale3(0.25)*unitsphere; // unitsphere has radius 1?
surface microphone = createCenteredBox((0.4, 0.8, 0.4));

// Draw the Walls
drawBox(No, A, identity4, mLightGreen);
drawBox(No, C, identity4, mLightBlue);

// Draw the points
draw(shift(No)*point,mBlack);
draw(shift(A)*point,mBlack);
draw(shift(B)*point,mBlack);
draw(shift(C)*point,mBlack);
draw(shift(Q)*point,mRed);
draw(shift(Qz)*point,mBlack);
draw(shift(Qxz)*point,mBlack);

// Draw the microphone
draw(shift(Q-Y*2/3)*microphone,mRed);

// Draw cables
draw((A--Q), black);
draw((B--Q), black);
draw((C--Q), black);

// Draw dimensions
draw(shift(Y/2)*(A--B), black, Arrows3, Bars3(Y), PenMargins2); // Arrows3 is bi-directional
//draw("$12$", shift(up)*(A--B), Z, Arrows3, Bars3(Y), PenMargins2); // I can't figue out labels...
draw(shift(Y/2)*(B--C), black, Arrows3, Bars3(Y));
draw(shift(X/2)*(C--(15,0,0)), black, Arrows3, Bars3(X));

draw(shift(Y/2)*(No -- (0,0,8)), black, Arrows3, Bars3(Y));
draw(shift(-Y/2)*((0,0,8) -- (7,0,8)), black, Arrows3, Bars3(Y));
draw(shift(X/2)*((7,0,8) -- (7,5,8)), black, Arrows3, Bars3(X));
*/




\end{asy}


\end{document}
